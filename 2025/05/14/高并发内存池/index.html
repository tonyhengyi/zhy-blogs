
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>高并发内存池 | zhy-blogs</title>
    <meta name="author" content="zhyneko" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/zhy-blogs/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/zhy-blogs/js/lib/highlight.js"></script>



<script src="/zhy-blogs/js/lib/preview.js"></script>









<link rel="stylesheet" href="/zhy-blogs/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/zhy-blogs/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/zhy-blogs/">
            <span>ZHY-BLOGS</span>
        </a>
        
        <a href="/zhy-blogs/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/zhy-blogs/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/zhy-blogs/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/zhy-blogs/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/zhy-blogs/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ZHY-BLOGS</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/zhy-blogs/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/zhy-blogs/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/zhy-blogs/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/zhy-blogs/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/zhy-blogs/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>高并发内存池</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/5/14
        </span>
        
        <span class="category">
            <a href="/zhy-blogs/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                编程实战
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/zhy-blogs/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" style="color: #ff7d73">
                    高并发
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/zhy-blogs/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="color: #00a596">
                    内存管理
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <hr>
<h1 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h1><p>内存池是一种预分配内存并进行重复利用的技术，通过减少频繁的动态内存分配和释放操作，从而提高程序的运行效率，内存池通常预先分配一块大的内存区域，将其划分很多小块。需要时直接从这块区域中分配，而不是直接调用系统的动态分配函数，可以有效的减少系统调用带来的开销</p>
<h1 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h1><p>三层缓存构成</p>
<h2 id="thread-cache"><a href="#thread-cache" class="headerlink" title="thread cache"></a>thread cache</h2><p>线程缓存是每个线程独有的，每个线程独享一个cache，这也是这个内存池高效的地方，<br>thread cache是一个哈希桶拉链法+自由链表的结构</p>
<pre><code class="language-cpp">#pragma once

#include &quot;Common.h&quot;

class ThreadCache
&#123;
public:
	// 申请和释放内存对象
	void* Allocate(size_t size);
	void Deallocate(void* ptr, size_t size);

	// 从中心缓存获取对象
	void* FetchFromCentralCache(size_t index, size_t size);

	// 释放对象时，链表过长时，回收内存回到中心缓存
	void ListTooLong(FreeList&amp; list, size_t size);
private:
	FreeList _freeLists[NFREELIST];
&#125;;

// TLS thread local storage
static _declspec(thread) ThreadCache* pTLSThreadCache = nullptr;
</code></pre>
<p>因为trheadcache使用的是哈希桶结构<br>不分段的话若全是按8字节分，则会需要32768个桶，但但是每个桶都是16Byte则会差生较多的内存碎片。因此这里采用了不同段的内存使用不同的内存对齐规则，既控制了桶的数量不会太多，又整体将内存碎片浪费控制在10%左右</p>
<p>内存对齐的函数的接口</p>
<pre><code class="language-cpp">//管理对齐和映射等关系
class SizeClass
&#123;
public:
	//获取向上对齐后的字节数
	static inline size_t RoundUp(size_t bytes);
	//获取对应哈希桶的下标
	static inline size_t Index(size_t bytes);
&#125;;
</code></pre>
<p>对齐映射规则</p>
<pre><code class="language-cpp">static inline size_t _RoundUp(size_t bytes, size_t alignNum)
	&#123;
		return ((bytes + alignNum - 1) &amp; ~(alignNum - 1));
	&#125;
	//内联函数：调用频繁，因此写成内联函数
	//向上对齐
	static inline size_t RoundUp(size_t size)
	&#123;
		if (size &lt;= 128)
		&#123;
			return _RoundUp(size, 8);
		&#125;
		else if (size &lt;= 1024)
		&#123;
			return _RoundUp(size, 16);
		&#125;
		else if (size &lt;= 8*1024)
		&#123;
			return _RoundUp(size, 128);
		&#125;
		else if (size &lt;= 64*1024)
		&#123;
			return _RoundUp(size, 1024);
		&#125;
		else if (size &lt;= 256 * 1024)
		&#123;
			return _RoundUp(size, 8*1024);
		&#125;
		else//size &gt; 256 * 1024 byte 
		&#123;
			return _RoundUp(size, 1&lt;&lt;PAGE_SHIFT);
		&#125;
	&#125;

	static inline size_t _Index(size_t bytes, size_t align_shift)
	&#123;
		return ((bytes + (1 &lt;&lt; align_shift) - 1) &gt;&gt; align_shift) - 1;
	&#125;
	//计算映射的哪一个自由链表桶中
	static inline size_t Index(size_t bytes)
	&#123;
		assert(bytes &lt;= MAX_BYTES);
		static int group_array[4] = &#123; 16, 56, 56, 56 &#125;;
		if (bytes &lt;= 128)
		&#123;
			return _Index(bytes, 3);
		&#125;
		else if (bytes &lt;= 1024)
		&#123;
			return _Index(bytes - 128, 4) + group_array[0];
		&#125;
		else if (bytes &lt;= 8 * 1024)
		&#123;
			return _Index(bytes - 1024, 7) + group_array[0] + group_array[1];
		&#125;
		else if (bytes &lt;= 64 * 1024)
		&#123;
			return _Index(bytes - 8 * 1024, 10) + group_array[0] + group_array[1] + group_array[2];
		&#125;
		else if (bytes &lt;= 256 * 1024)
		&#123;
			return _Index(bytes - 64 * 1024, 13) + group_array[0] + group_array[1] + group_array[2] + group_array[3];
		&#125;
		else
		&#123;
			assert(false);
			return -1;
		&#125;
	&#125;
</code></pre>
<h2 id="central-cache"><a href="#central-cache" class="headerlink" title="central cache"></a>central cache</h2><p>中心缓存所有线程共享，当我们的thread cache没有内存块时会向central cache申请，central cahce也是一个哈希桶的结构，不过它挂载的是Span List链表结构，Span List中则有一个个相同大小的内存块按照哈希桶的映射后，通过双向链表的形式挂在相应的Span上，</p>
<p>Central Cache本质是由一个哈希映射的span对象自由双向链表构成<br>为了保证全局只有唯一的Central Cache,这个类因此可以被设计称单例模式(这里使用的是饿汉模式)<br>饿汉模式：构造函数私有，对象设为静态私有。拷贝构造和赋值重载设为delete（防拷贝）</p>
<pre><code class="language-cpp">
#pragma once

#include &quot;Common.h&quot;

// 单例模式
class CentralCache
&#123;
public:
	static CentralCache* GetInstance()
	&#123;
		return &amp;_sInst;
	&#125;
	// 获取一个非空的span
	Span* GetOneSpan(SpanList&amp; list, size_t byte_size);
	// 从中心缓存获取一定数量的对象给thread cache
	size_t FetchRangeObj(void*&amp; start, void*&amp; end, size_t batchNum, size_t size);
	// 将一定数量的对象释放到span跨度
	void ReleaseListToSpans(void* start, size_t byte_size);
private:
	SpanList _spanLists[NFREELIST];
private:
	CentralCache()
	&#123;&#125;
	CentralCache(const CentralCache&amp;) = delete;
	static CentralCache _sInst;
&#125;;
</code></pre>
<p>span的结构</p>
<pre><code class="language-cpp">//管理多个连续页的大块内存跨度结构
struct Span
&#123;
	PAGE_ID _pageId = 0;//大块内存起始页的页号
	size_t _n = 0;//页的数量

	Span* _next = nullptr;//双向链表的结构
	Span* _prev = nullptr;

	size_t _objSize = 0;//切好的小对象的大小
	size_t _usecount = 0;//切好的小块内存，被分配给thread cache的计数
	void* _freeList = nullptr;//切好的小块内存的自由链表

	bool _isUse = false;//是否在被使用
&#125;;
</code></pre>
<p>使用双向链表来管理，下面是双向链表的结构<br>spanList</p>
<pre><code class="language-cpp">//带头双向循环链表
class SpanList
&#123;
public:
	SpanList()
	&#123;
		_head = new Span;
		_head-&gt;_next = _head;
		_head-&gt;_prev = _head;
	&#125;

	void Insert(Span* pos, Span* newSpan)
	&#123;
		assert(pos);
		assert(newSpan);
		Span* prev = pos-&gt;_prev;
		prev-&gt;_next = newSpan;
		newSpan-&gt;_prev = prev;
		newSpan-&gt;_next = pos;
		pos-&gt;_prev = newSpan;
	&#125;

	Span* Begin()
	&#123;
		return _head-&gt;_next;
	&#125;

	Span* End()
	&#123;
		return _head;
	&#125;

	bool Empty()
	&#123;
		return _head-&gt;_next == _head;
	&#125;
	void PushFront(Span* span)
	&#123;
		Insert(Begin(), span);
	&#125;

	Span* PopFront()
	&#123;
		Span* front = _head-&gt;_next;
		Erase(front);
		return front;
	&#125;
	void Erase(Span* pos)
	&#123;
		assert(pos);
		assert(pos != _head);

		Span* prev = pos-&gt;_prev;
		Span* next = pos-&gt;_next;
		prev-&gt;_next = next;
		next-&gt;_prev = prev;
	&#125;
public:
	std::mutex _mtx;//桶锁
private:
	Span* _head;
&#125;;
</code></pre>
<h2 id="page-cache"><a href="#page-cache" class="headerlink" title="page cache"></a>page cache</h2><p>存储的内存以page为单位存储以及分配的，当central cache没有内存对象时，我们从page cache分配出一定数量的page，并切割成定长大小的小块内存，分配给central cache，当一个span的几个跨度页的对象都收回以后，page cache会回收central cache满足条件的span对象，合并相邻的页，组成更大的页，这样缓解内存碎片问题</p>
<p>page的任务是<br>检查central cache申请的相应位置是否合法，如果没有合适的span,需要从较大的span中分裂两个<br>如果找到链表的最后都没有合适的span，则在系统中使用VirtualAlloc申请一个较大的span。<br>pagecache中的spanlist与前两个采用不同的内存对齐原则，直接就是1page,2page,3page<br>框架</p>
<pre><code class="language-cpp">#pragma once

#include &quot;Common.h&quot;
#include &quot;ObjectPool.h&quot;
#include &quot;PageMap.h&quot;

class PageCache
&#123;
public:
	static PageCache* GetInstance()
	&#123;
		return &amp;_sInst;
	&#125;

	// 获取从对象到span的映射
	Span* MapObjectToSpan(void* obj);

	// 释放空闲span回到Pagecache，并合并相邻的span
	void ReleaseSpanToPageCache(Span* span);

	// 获取一个K页的span
	Span* NewSpan(size_t k);

	std::mutex _pageMtx;
private:
	SpanList _spanLists[NPAGES];
	ObjectPool&lt;Span&gt; _spanPool;

	//std::unordered_map&lt;PAGE_ID, Span*&gt; _idSpanMap;
	//std::map&lt;PAGE_ID, Span*&gt; _idSpanMap;
	TCMalloc_PageMap1&lt;32 - PAGE_SHIFT&gt; _idSpanMap;

	PageCache()
	&#123;&#125;
	PageCache(const PageCache&amp;) = delete;


	static PageCache _sInst;
&#125;;
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2025 zhy-blogs
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;zhyneko
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/zhy-blogs/js/main.js"></script>
    
    




    
</body>
</html>
